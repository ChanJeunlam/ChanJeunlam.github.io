---
layout: post

title: "Python整洁之道"

date: 2023-02-08

description: "主要包括Python"

tag: Python
---
# 断言

断言是为了告诉开发人员程序中发生了不可恢复的错误。对于可以预料的错误（如未找到相关文件），用户可以予以纠正或重试，断言并不是为此而生的。

断言用于程序内部自检，如声明一些代码中不可能出现的条件。如果触发了某个条件，即意味着程序中存在相应的 bug。

## 断言语法

```python
assert_stmt ::="assert" expression1 ["," expression2]
```

其中，expression1 是需要测试的条件，可选的 expression2 是错误消息，如果断言失败则显示该消息。

","表示逗号，expression1 和 expression2 之间用逗号分隔。

在执行时，Python 解释器将每条断言语句大致转换为以下这些语句：

```python
if __debug__:
    if not expression1:
        raise AssertionError(expression2)
```

代码在检查断言条件之前，还会检查__debug__全局变量。这是一个内置的布尔标记，在一般情况下为真，若进行代码优化则为假。还可以使用 expression2 传递一个可选的错误消息，该消息将与回溯中的AssertionError 一起显示，用来进一步简化调试。

## 断言注意事项

### 不要使用断言验证数据

在 Python 中使用断言时要注意的一个重点是，若在命令行中使用-O 和-OO 标识，或修改CPython中的 PYTHONOPTIMIZE 环境变量，都会全局禁用断言。

不要使用断言验证数据，因为当全局禁用断言时，验证失效，可能存在严重的安全漏洞。

### 永不失败的断言

在将一个元组作为 assert 语句中的第一个参数传递时，断言条件总为真，因此永远不会失败。

```python
assert(1 == 2, 'This should fail') 
```

这是因为在 Python 中非空元组总为真值。如果将元组传递给 assert 语句，则会导致断言条件始终为真，因此上述 assert 语句毫无用处，永远不会触发异常。

这也是为什么应该总是对单元测试用例先做一个快速的冒烟测试。要确保在编
写下一个测试之前，当前测试用例的确会失败。

### 断言总结

1. Python 断言语句是一种测试某个条件的调试辅助功能，可作为程序的内部自检
2. 断言应该只用于帮助开发人员识别 bug，它不是用于处理运行时错误的机制。

# 巧妙放置逗号

如果需要在 Python 中的列表、字典或集合常量中添加或移除项，记住一个窍门：在所有行后面都添加一个逗号。

如，假设代码中有如下名字组成的列表：

```python
names = ['Alice', 'Bob', 'Cindy', 'Doug']
```

在修改这个名字列表时，通过 git diff 查看改动可能有点不方便。大多数源码控制系统都是基于行的，因此无法标出同一行中的多个改动。

一个快速改进是根据编码规范，将列表、字典或集合常量分割成多行，如下所示：

```python
names = [
    'Alice',
    'Bob',
    'Cindy'
    'Doug'
]
```

在列表末尾添加或移除内容时Jane，需要在'Doug'后面添加逗号，再添加或移除新的名字。否则，Python就会将字符串 Doug 和 Jane 合并成了 DougJane。这称为**字符串字面值**拼接，是文档中有记录的刻意行为，这种行为可能会在程序中引入令人难以琢磨的 bug。

在某些情况下，字符串字面值拼接是一个有用的特性。例如，在跨越多行的长字符串中可以省去反斜杠：

```python
long_string = 'This is a very long string. ' \
              'It continues here.'
```

